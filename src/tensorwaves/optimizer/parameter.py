"""Utility to splice (flatten) and merge (unflatten) complex parameters for 'real-only' optimizers."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Mapping

    from tensorwaves.interface import ParameterValue


class ParameterFlattener:
    """Utility-class to flatten complex parameters.

    Args:
        parameters: Original parameter-dictionary (unflattened). Non-complex values will
            not be affected by any method.
    """

    def __init__(self, parameters: Mapping[str, ParameterValue]) -> None:
        self.__real_imag_to_complex_name: dict[str, str] = {}
        self.__complex_to_real_imag_name: dict[str, tuple[str, str]] = {}
        for name, val in parameters.items():
            if isinstance(val, complex):
                real_name = f"real_{name}"
                imag_name = f"imag_{name}"
                self.__real_imag_to_complex_name[real_name] = name
                self.__real_imag_to_complex_name[imag_name] = name
                self.__complex_to_real_imag_name[name] = (real_name, imag_name)

    def unflatten(
        self, flattened_parameters: dict[str, float]
    ) -> dict[str, ParameterValue]:
        """Reverse the flattening operation.

        Takes a parameter-dictionary and merges all real and imaginary values whose
        respective keys have been registered in the constructor of the
        `ParameterFlattener` into a complex number. Specifically, while this works also
        on inputs which have not been generated by :meth:`.flatten` their outputs might
        be unexpected.

        Args:
            flattened_parameters: parameter `dict` whose values are to be unflattened.
        """
        parameters: dict[str, ParameterValue] = {
            k: v
            for k, v in flattened_parameters.items()
            if k not in self.__real_imag_to_complex_name
        }
        for complex_name, (
            real_name,
            imag_name,
        ) in self.__complex_to_real_imag_name.items():
            parameters[complex_name] = complex(
                flattened_parameters[real_name],
                flattened_parameters[imag_name],
            )
        return parameters

    def flatten(self, parameters: Mapping[str, ParameterValue]) -> dict[str, float]:
        """Flatten the parameter-values whose keys have been registered in the constructor.

        Splits all complex values whose keys have been registered in the constructor of
        `ParameterFlattener` into their real and imaginary parts. Their keys are
        predetermined by the constructor. Other key-value pairs remain unchanged.

        Args:
            parameters: parameter `dict` whose values are to be flattened.
        """
        flattened_parameters: dict[str, float] = {}
        for par_name, value in parameters.items():
            if isinstance(value, complex):
                if par_name not in self.__complex_to_real_imag_name:
                    msg = (
                        f"Parameter '{par_name}' has was not registered upon"
                        f" constructing the {type(self).__name__}"
                    )
                    raise ValueError(msg)
                name_pair = self.__complex_to_real_imag_name[par_name]
                real_name, imag_name = name_pair
                flattened_parameters[real_name] = value.real
                flattened_parameters[imag_name] = value.imag
            else:
                flattened_parameters[par_name] = value
        return flattened_parameters
